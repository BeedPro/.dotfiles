#!/usr/bin/env python3

import subprocess
import sys
import curses
import os
from pathlib import Path


SRC_DIR = Path.home() / ".local" / "src"
SRC_DIR.mkdir(parents=True, exist_ok=True)

TMUX_PREFIX = "* "
SESH_PREFIX = "@ "
DIR_PREFIX = "+ "


def is_valid_base(path: Path) -> bool:
    return path.is_dir()


def relative_depth(root: str, base_depth: int) -> int:
    return len(Path(root).parts) - base_depth


def handle_depth(
    root: str,
    dirs: list[str],
    current_depth: int,
    target_depth: int,
    base: Path,
    result: list[str],
) -> None:
    if current_depth > target_depth:
        dirs.clear()
        return

    if current_depth == target_depth:
        relative = Path(root).resolve().relative_to(base)
        result.append(relative.as_posix())
        dirs.clear()


def find_dirs(input: str, depth: int = 1) -> list[str]:
    base = Path(input).expanduser().resolve()
    result: list[str] = []

    if not is_valid_base(base):
        return result

    base_depth = len(base.parts)

    for root, dirs, _ in os.walk(base):
        current = relative_depth(root, base_depth)
        handle_depth(root, dirs, current, depth, base, result)

    return result


def add_paths(
    output: dict[str, str],
    items: list[str],
    prefix: str,
    base_path: str,
) -> None:
    for p in items:
        key = f"{prefix}{p}" if prefix else p
        output[key] = f"{base_path}/{p}"


def create_mapping(paths: list[str]) -> dict[str, str]:
    src: list[str] = find_dirs(paths[0], 2)
    share: list[str] = find_dirs(paths[1])
    config: list[str] = find_dirs(paths[2])
    output: dict[str, str] = {}

    add_paths(
        output,
        src,
        "",
        paths[0],
    )
    add_paths(output, share, "share/", paths[1])
    add_paths(output, config, "config/", paths[2])

    return output


def run(cmd, check=True, capture_output=False, text=True):
    return subprocess.run(
        cmd,
        check=check,
        capture_output=capture_output,
        text=text,
    )


def ensure_session(session_name: str, directory: Path) -> None:
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    if result.returncode != 0:
        subprocess.run(
            [
                "tmux",
                "new-session",
                "-ds",
                session_name,
                "-c",
                str(directory.expanduser().resolve()),
            ]
        )
    run(["tmux", "switch-client", "-t", session_name])


def fuzzy_score(query: str, candidate: str) -> int | None:
    """
    Simple ordered-subsequence matcher.
    Lower score is better. None = no match.
    """
    if not query:
        return 0

    it = iter(candidate.lower())
    score = 0

    for ch in query.lower():
        for c in it:
            score += 1
            if c == ch:
                break
        else:
            return None

    return score


def get_tmux_items() -> list[str]:
    result = subprocess.run(
        ["tmux", "list-sessions", "-F", "#S"],
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL,
        text=True,
    )
    if result.returncode != 0:
        return []
    return result.stdout.splitlines()


def get_sesh_items() -> list[str]:
    return run(["sesh", "list", "-c"], capture_output=True).stdout.splitlines()


def get_all_items(paths: list[str]) -> tuple[list[str], dict[str, str]]:
    mapping = create_mapping(paths)

    sesh_items = get_sesh_items()
    tmux_items = get_tmux_items()

    sesh_set = set(sesh_items)
    tmux_set = set(tmux_items)
    mapping_keys = set(mapping.keys())

    display_items: list[str] = []

    for name in sorted(tmux_set):
        display_items.append(f"{TMUX_PREFIX}{name}")

    for name in sorted(sesh_set - tmux_set):
        display_items.append(f"{SESH_PREFIX}{name}")

    for name in sorted(mapping_keys - sesh_set - tmux_set):
        display_items.append(f"{DIR_PREFIX}{name}")

    return display_items, mapping


def compute_results(items: list[str], query: str, height: int) -> list[str]:
    matches = []
    for item in items:
        score = fuzzy_score(query, item)
        if score is not None:
            matches.append((score, item))

    matches.sort(key=lambda x: x[0])
    return [m[1] for m in matches][: height - 2]


def draw_screen(stdscr, query: str, results: list[str], index: int) -> None:
    stdscr.clear()
    _, w = stdscr.getmaxyx()

    stdscr.addstr(0, 0, f"> {query}")

    for i, item in enumerate(results):
        prefix = "  " if i == index else "  "
        if i == index:
            stdscr.attron(curses.A_REVERSE)

        stdscr.addstr(i + 1, 0, prefix + item[: w - 3])

        if i == index:
            stdscr.attroff(curses.A_REVERSE)

    stdscr.refresh()


def handle_key(
    key: int,
    query: str,
    index: int,
    results: list[str],
) -> tuple[str | None, str, int]:
    if key in (curses.KEY_ENTER, 10, 13):
        if results:
            return results[index], query, index
        return query, query, index

    if key in (27, 3):
        return "", query, index

    if key in (curses.KEY_BACKSPACE, 127):
        return None, query[:-1], 0

    # Next (↓ or Ctrl-n)
    if key in (curses.KEY_DOWN, 14):
        return None, query, min(index + 1, max(0, len(results) - 1))

    # Previous (↑ or Ctrl-p)
    if key in (curses.KEY_UP, 16):
        return None, query, max(index - 1, 0)

    if 32 <= key <= 126:
        return None, query + chr(key), 0

    return None, query, index


def curses_ui(stdscr, items: list[str]) -> str:
    curses.curs_set(1)
    curses.start_color()
    curses.use_default_colors()
    stdscr.bkgd(" ", curses.A_NORMAL)
    query = ""
    index = 0

    while True:
        h, _ = stdscr.getmaxyx()
        results = compute_results(items, query, h)
        draw_screen(stdscr, query, results, index)

        key = stdscr.getch()
        result, query, index = handle_key(key, query, index, results)

        if result is not None:
            return result


def fuzzy_select(items: list[str]) -> str:
    return curses.wrapper(curses_ui, items)


def main() -> None:
    paths: list[str] = [
        "~/.local/src",
        "~/.dotfiles/.local/share",
        "~/.dotfiles/.config",
    ]

    items, mapping = get_all_items(paths)
    selected = fuzzy_select(items)

    if not selected:
        return

    selected = selected[2:]

    if selected in mapping:
        ensure_session(selected, Path(mapping[selected]))
        return

    run(["sesh", "connect", selected])


if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)
