#!/usr/bin/env python3

import re
import subprocess
import sys
import curses
from pathlib import Path


SRC_DIR = Path.home() / ".local" / "src"
SRC_DIR.mkdir(parents=True, exist_ok=True)


def run(cmd, check=True, capture_output=False, text=True):
    return subprocess.run(
        cmd,
        check=check,
        capture_output=capture_output,
        text=text,
    )


def ensure_session(session_name: str, directory: Path) -> None:
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    if result.returncode != 0:
        run(["tmux", "new-session", "-ds", session_name, "-c", str(directory)])
    run(["tmux", "switch-client", "-t", session_name])


def fuzzy_score(query: str, candidate: str) -> int | None:
    """
    Simple ordered-subsequence matcher.
    Lower score is better. None = no match.
    """
    if not query:
        return 0

    it = iter(candidate.lower())
    score = 0

    for ch in query.lower():
        for c in it:
            score += 1
            if c == ch:
                break
        else:
            return None

    return score


def get_sesh_items() -> list[str]:
    return run(["sesh", "list", "-c"], capture_output=True).stdout.splitlines()


def compute_results(items: list[str], query: str, height: int) -> list[str]:
    matches = []
    for item in items:
        score = fuzzy_score(query, item)
        if score is not None:
            matches.append((score, item))

    matches.sort(key=lambda x: x[0])
    return [m[1] for m in matches][: height - 2]


def draw_screen(stdscr, query: str, results: list[str], index: int) -> None:
    stdscr.clear()
    _, w = stdscr.getmaxyx()

    stdscr.addstr(0, 0, f"> {query}")

    for i, item in enumerate(results):
        prefix = "  " if i == index else "  "
        if i == index:
            stdscr.attron(curses.A_REVERSE)

        stdscr.addstr(i + 1, 0, prefix + item[: w - 3])

        if i == index:
            stdscr.attroff(curses.A_REVERSE)

    stdscr.refresh()


def handle_key(
    key: int,
    query: str,
    index: int,
    results: list[str],
) -> tuple[str | None, str, int]:
    if key in (curses.KEY_ENTER, 10, 13):
        if results:
            return results[index], query, index
        return query, query, index

    if key in (27, 3):
        return "", query, index

    if key in (curses.KEY_BACKSPACE, 127):
        return None, query[:-1], 0

    if key == curses.KEY_DOWN:
        return None, query, min(index + 1, max(0, len(results) - 1))

    if key == curses.KEY_UP:
        return None, query, max(index - 1, 0)

    if 32 <= key <= 126:
        return None, query + chr(key), 0

    return None, query, index


def curses_ui(stdscr, items: list[str]) -> str:
    curses.curs_set(1)
    curses.start_color()
    curses.use_default_colors()
    stdscr.bkgd(" ", curses.A_NORMAL)
    query = ""
    index = 0

    while True:
        h, _ = stdscr.getmaxyx()
        results = compute_results(items, query, h)
        draw_screen(stdscr, query, results, index)

        key = stdscr.getch()
        result, query, index = handle_key(key, query, index, results)

        if result is not None:
            return result


def fuzzy_select() -> str:
    items = get_sesh_items()
    return curses.wrapper(curses_ui, items)


def is_git_url(value: str) -> bool:
    return bool(re.match(r"^(https?://|git@[^:]+:|ssh://git@[^/]+/|gh:)", value))


def clean_repo_path(url: str) -> str:
    cleaned = re.sub(r"^ssh://git@[^/]+/", "", url)
    cleaned = re.sub(r"^git@[^:]+:", "", cleaned)
    cleaned = re.sub(r"^https?://[^/]+/", "", cleaned)
    cleaned = re.sub(r"(\.git)?$", "", cleaned)
    return cleaned


def main() -> None:
    selected = fuzzy_select()

    if not selected:
        return

    if is_git_url(selected):
        clean = clean_repo_path(selected)
        target = SRC_DIR / clean

        if not (target / ".git").is_dir():
            target.parent.mkdir(parents=True, exist_ok=True)
            run(["git", "clone", selected, str(target)])

        ensure_session(clean, target)
        return

    # Use last line if fzf returned query + selection
    selected = selected.splitlines()[-1]

    if selected:
        run(["sesh", "connect", selected])


if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)
